package shell

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// DotfilesStrategy defines how to handle existing dotfiles
type DotfilesStrategy int

const (
	// MergeWithExisting merges our configs with existing ones
	MergeWithExisting DotfilesStrategy = iota
	// SkipIfExists skips adding configs that already exist
	SkipIfExists
	// ReplaceExisting replaces existing configs with ours
	ReplaceExisting
)

// ConfigWriter handles writing shell configurations
type ConfigWriter interface {
	// WriteConfig writes a configuration to the shell's config file
	WriteConfig(shell Shell, config string, strategy DotfilesStrategy) error
	// AddToPath adds a path to the shell's PATH variable
	AddToPath(shell Shell, path string, strategy DotfilesStrategy) error
	// SetEnvVar sets an environment variable in the shell's config
	SetEnvVar(shell Shell, key, value string, strategy DotfilesStrategy) error
	// AddAlias adds an alias to the shell's config
	AddAlias(shell Shell, name, command string, strategy DotfilesStrategy) error
	// AddSource adds a source command to the shell's config
	AddSource(shell Shell, file string, strategy DotfilesStrategy) error
	// HasConfig checks if a specific configuration already exists
	HasConfig(shell Shell, config string) bool
}

// DefaultConfigWriter is the default implementation of ConfigWriter
type DefaultConfigWriter struct {
	manager Manager
}

// NewConfigWriter creates a new shell config writer
func NewConfigWriter(manager Manager) ConfigWriter {
	return &DefaultConfigWriter{
		manager: manager,
	}
}

// WriteConfig writes a configuration to the shell's config file
func (w *DefaultConfigWriter) WriteConfig(shell Shell, config string, strategy DotfilesStrategy) error {
	// Get shell info
	info, err := w.manager.GetInfo(shell)
	if err != nil {
		return fmt.Errorf("failed to get shell info: %w", err)
	}

	// Get the primary config file
	configFile := info.ConfigFiles[0]
	if configFile == "" {
		return fmt.Errorf("no config file found for shell %s", shell)
	}

	// Check if config already exists
	if strategy != ReplaceExisting && w.HasConfig(shell, config) {
		if strategy == SkipIfExists {
			return nil // Skip if already exists and strategy is SkipIfExists
		}
		// For MergeWithExisting, we'll add our config after existing ones
	}

	// Read existing config
	existingConfig, err := os.ReadFile(configFile)
	if err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("failed to read config file: %w", err)
	}

	// Prepare new config
	var newConfig string
	if len(existingConfig) > 0 {
		// Add a separator if there's existing content
		newConfig = string(existingConfig) + "\n\n# Added by bootstrap-cli\n" + config
	} else {
		newConfig = "# Generated by bootstrap-cli\n" + config
	}

	// Ensure directory exists
	dir := filepath.Dir(configFile)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create config directory: %w", err)
	}

	// Write config
	if err := os.WriteFile(configFile, []byte(newConfig), 0644); err != nil {
		return fmt.Errorf("failed to write config file: %w", err)
	}

	return nil
}

// AddToPath adds a path to the shell's PATH variable
func (w *DefaultConfigWriter) AddToPath(shell Shell, path string, strategy DotfilesStrategy) error {
	var config string

	switch shell {
	case Bash, Zsh:
		config = fmt.Sprintf("export PATH=\"%s:$PATH\"", path)
	case Fish:
		config = fmt.Sprintf("set -gx PATH %s $PATH", path)
	default:
		return fmt.Errorf("unsupported shell type: %s", shell)
	}

	return w.WriteConfig(shell, config, strategy)
}

// SetEnvVar sets an environment variable in the shell's config
func (w *DefaultConfigWriter) SetEnvVar(shell Shell, key, value string, strategy DotfilesStrategy) error {
	var config string

	switch shell {
	case Bash, Zsh:
		config = fmt.Sprintf("export %s=\"%s\"", key, value)
	case Fish:
		config = fmt.Sprintf("set -gx %s %s", key, value)
	default:
		return fmt.Errorf("unsupported shell type: %s", shell)
	}

	return w.WriteConfig(shell, config, strategy)
}

// AddAlias adds an alias to the shell's config
func (w *DefaultConfigWriter) AddAlias(shell Shell, name, command string, strategy DotfilesStrategy) error {
	var config string

	switch shell {
	case Bash, Zsh:
		config = fmt.Sprintf("alias %s='%s'", name, command)
	case Fish:
		config = fmt.Sprintf("alias %s='%s'", name, command)
	default:
		return fmt.Errorf("unsupported shell type: %s", shell)
	}

	return w.WriteConfig(shell, config, strategy)
}

// AddSource adds a source command to the shell's config
func (w *DefaultConfigWriter) AddSource(shell Shell, file string, strategy DotfilesStrategy) error {
	var config string

	switch shell {
	case Bash, Zsh:
		config = fmt.Sprintf("source %s", file)
	case Fish:
		config = fmt.Sprintf("source %s", file)
	default:
		return fmt.Errorf("unsupported shell type: %s", shell)
	}

	return w.WriteConfig(shell, config, strategy)
}

// HasConfig checks if a specific configuration already exists
func (w *DefaultConfigWriter) HasConfig(shell Shell, config string) bool {
	// Get shell info
	info, err := w.manager.GetInfo(shell)
	if err != nil {
		return false
	}

	// Get the primary config file
	configFile := info.ConfigFiles[0]
	if configFile == "" {
		return false
	}

	// Read config file
	content, err := os.ReadFile(configFile)
	if err != nil {
		return false
	}

	contentStr := string(content)

	// Check if config exists
	// For simple configs (not export/set commands), do exact match
	if !strings.HasPrefix(config, "export ") && !strings.HasPrefix(config, "set -gx ") {
		return strings.Contains(contentStr, config)
	}

	// For export/set commands, check for similar patterns
	// Extract the variable name from the config
	var varName string
	switch {
	case strings.HasPrefix(config, "export "):
		parts := strings.SplitN(config[7:], "=", 2)
		varName = strings.TrimSpace(parts[0])
	case strings.HasPrefix(config, "set -gx "):
		parts := strings.SplitN(config[8:], " ", 2)
		varName = strings.TrimSpace(parts[0])
	default:
		return false
	}

	// Look for any line containing this variable name
	lines := strings.Split(contentStr, "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}
		if strings.Contains(line, "export "+varName+"=") || strings.Contains(line, "set -gx "+varName+" ") {
			return true
		}
	}

	return false
} 