package components

import (
	"fmt"

	"github.com/YitzhakMizrahi/bootstrap-cli/internal/ui/styles" // Import our styles
	"github.com/charmbracelet/bubbles/list"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	// Import lipgloss for direct use if needed
)

// SelectorItem represents an item in the selection list
type SelectorItem struct {
	title       string
	description string
	item        interface{} // The actual data item
	selected    bool
}

// FilterValue implements list.Item interface
func (i SelectorItem) FilterValue() string { return i.title }

// Title returns the title for the list item
func (i SelectorItem) Title() string {
	var checkbox string
	if i.selected {
		checkbox = "[x]" // Simple checkbox string
	} else {
		checkbox = "[ ]"
	}
	// Return plain string - delegate handles styling
	return checkbox + " " + i.title
}

// Description returns the description for the list item
func (i SelectorItem) Description() string {
	// Return plain string - delegate handles styling
	return i.description
}

// BaseSelector is the main model for selection
type BaseSelector struct {
	list         list.Model
	selectedItems map[interface{}]struct{} // Stores the actual selected data items for quick lookup
	quitting     bool
	done         bool
	title        string
	// selectable func(interface{}) bool // This might be complex to integrate with list's filtering
}

// NewBaseSelector creates a new base selector
func NewBaseSelector(title string) *BaseSelector {
	delegate := list.NewDefaultDelegate()

	// Make selected item more distinct
	delegate.Styles.SelectedTitle = styles.SelectedTextStyle.Copy().
		Border(lipgloss.NormalBorder(), false, false, false, true). // Left border
		BorderForeground(styles.ColorAccent). // Accent color border
		Padding(0, 0, 0, 1) // Adjust padding slightly

	delegate.Styles.SelectedDesc = styles.UnselectedTextStyle.Copy(). // Keep desc dim but add border
		Border(lipgloss.NormalBorder(), false, false, false, true).
		BorderForeground(styles.ColorAccent).
		Padding(0, 0, 0, 1) // Match padding

	// Keep normal styles simple
	delegate.Styles.NormalTitle = styles.NormalTextStyle.Copy().Padding(0,0,0,2) // Standard indent
	delegate.Styles.NormalDesc = styles.UnselectedTextStyle.Copy().Padding(0,0,0,2) // Standard indent

	// Delegate height should account for potential description line
	delegate.SetHeight(2) // Allocate 2 lines per item (title + desc)
	delegate.SetSpacing(1) // Add spacing between items

	l := list.New([]list.Item{}, delegate, 0, 0) // Initial size 0,0

	if title != "" {
		l.Title = title
		l.Styles.Title = styles.ListTitleStyle
		l.SetShowTitle(true)
	} else {
		l.SetShowTitle(false)
	}
	
	l.Styles.HelpStyle = styles.KeyMapStyle
	l.Styles.StatusBar = styles.KeyMapStyle.Copy()
	l.Styles.FilterPrompt = styles.InfoStyle.Copy()
	l.Styles.FilterCursor = styles.InfoStyle.Copy()

	l.SetShowHelp(true)
	l.SetFilteringEnabled(true)
	l.SetShowStatusBar(true)

	return &BaseSelector{
		list:          l,
		selectedItems: make(map[interface{}]struct{}),
		title:         title,
	}
}

// Init implements tea.Model
func (s *BaseSelector) Init() tea.Cmd {
	return tea.EnterAltScreen // Good practice for full-screen components
}

// Update handles keyboard input and updates the selector state
func (s *BaseSelector) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmds []tea.Cmd
	var cmd tea.Cmd

	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		s.list.SetSize(msg.Width, msg.Height)
		return s, nil

	case tea.KeyMsg:
		if s.list.FilterState() == list.Filtering {
			break // Let the list handle filtering keys
		}
		switch msg.String() {
		case "ctrl+c", "q":
			s.quitting = true
			s.done = false
			return s, tea.Quit // Quit app on ctrl+c or q
		case "enter":
			s.done = true
			s.quitting = false
			// Return nil command. The parent app model will detect Finished() state.
			return s, nil // <<< FIX: Was tea.Quit
		case " ": // Spacebar to toggle selection
			if s.list.FilterState() == list.Filtering { break }
			currentItem, ok := s.list.SelectedItem().(*SelectorItem) 
			if !ok { return s, nil }

			currentItem.selected = !currentItem.selected // Toggle internal state
			if currentItem.selected {
				s.selectedItems[currentItem.item] = struct{}{}
			} else {
				delete(s.selectedItems, currentItem.item)
			}

            // --- REMOVE SetItem call --- 
			// No need to call SetItem; the change to currentItem.selected 
            // will be reflected when the list's View() is called next.
			// cmd = s.list.SetItem(idx, currentItem) 
            // cmds = append(cmds, cmd)
            // --- END REMOVE ---

			// Return existing commands (if any were generated by list.Update earlier)
			return s, tea.Batch(cmds...)
		}
	}

	// Pass unmatched messages down to the list for default handling
	s.list, cmd = s.list.Update(msg)
	cmds = append(cmds, cmd)
	return s, tea.Batch(cmds...)
}

// View implements tea.Model
func (s *BaseSelector) View() string {
	if s.quitting && !s.done {
		return styles.InfoStyle.Render("Selection cancelled.")
	}
	// The list component handles its own rendering including title, items, help, status bar, etc.
	return s.list.View()
}

// Finished returns true if the selector was completed normally (not quit)
func (s *BaseSelector) Finished() bool {
	return s.done && !s.quitting
}

// GetSelected returns the slice of selected actual data items
func (s *BaseSelector) GetSelected() []interface{} {
	if !s.Finished() {
		return nil
	}
	var result []interface{}
	for item := range s.selectedItems {
		result = append(result, item)
	}
	return result
}

// SetItems prepares SelectorItem for the list from a slice of actual data items
func (s *BaseSelector) SetItems(items []interface{}, titleFn func(interface{}) string, descFn func(interface{}) string) {
	listItems := make([]list.Item, len(items))
	for i, dataItem := range items {
		_, isSelected := s.selectedItems[dataItem] // Preserve selection if item already exists
		listItems[i] = &SelectorItem{
			title:       titleFn(dataItem),
			description: descFn(dataItem),
			item:        dataItem,
			selected:    isSelected,
		}
	}
	s.list.SetItems(listItems)
}

// SetSize sets the width and height of the selector - usually called on tea.WindowSizeMsg
func (s *BaseSelector) SetSize(width, height int) {
	s.list.SetSize(width, height)
}

// SetSelectedDataItems allows pre-selecting items by providing the actual data items
func (s *BaseSelector) SetSelectedDataItems(dataItemsToSelect []interface{}) {
	s.selectedItems = make(map[interface{}]struct{}) // Clear previous selections
	for _, dataItem := range dataItemsToSelect {
		s.selectedItems[dataItem] = struct{}{}
	}
	// Update the 'selected' field on the list.Item wrappers (SelectorItem)
	currentListItems := s.list.Items()
	for i, listItem := range currentListItems {
		if si, ok := listItem.(*SelectorItem); ok {
			if _, ok := s.selectedItems[si.item]; ok {
				si.selected = true
			} else {
				si.selected = false
			}
			_ = s.list.SetItem(i, si) // Update item in list for visual consistency
		}
	}
}

// RunSelector is a helper to start this TUI component and get selected items.
// It expects items as []interface{} and functions to get title/description.
func RunSelector(title string, items []interface{}, titleFn func(interface{}) string, descFn func(interface{}) string, preselected []interface{}) ([]interface{}, error) {
	selector := NewBaseSelector(title)
	selector.SetItems(items, titleFn, descFn)
	if len(preselected) > 0 {
		selector.SetSelectedDataItems(preselected)
	}

	p := tea.NewProgram(selector)
	finalModel, err := p.StartReturningModel()
	if err != nil {
		return nil, fmt.Errorf("error running selector: %w", err)
	}

	castedModel, ok := finalModel.(*BaseSelector)
	if !ok {
		return nil, fmt.Errorf("could not cast final model to BaseSelector")
	}

	if castedModel.Finished() {
		return castedModel.GetSelected(), nil
	}
	return nil, nil // Selection cancelled or quit
}

// Specific SetItems for common types (Tool, Font, Language) - REMOVED
// These are convenience wrappers around the generic SetItems.

// func (s *BaseSelector) SetToolItems(tools []*interfaces.Tool, preselectedTools []*interfaces.Tool) {
// 	genericItems := make([]interface{}, len(tools))
// 	for i, t := range tools { genericItems[i] = t }
// 	
// 	genericPreselected := make([]interface{}, len(preselectedTools))
// 	for i, t := range preselectedTools { genericPreselected[i] = t }
// 
// 	s.SetItems(genericItems, 
// 		func(item interface{}) string { return item.(*interfaces.Tool).Name }, 
// 		func(item interface{}) string { return item.(*interfaces.Tool).Description },
// 	)
// 	if len(genericPreselected) > 0 {
// 		s.SetSelectedDataItems(genericPreselected)
// 	}
// }

// Add similar SetFontItems, SetLanguageItems etc. as needed

